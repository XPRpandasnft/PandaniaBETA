import { Name, NameType, PermissionLevel, PermissionLevelType, PrivateKeyType, PublicKey, PublicKeyType } from '@greymass/eosio';
import { ChainId, ChainIdType, SigningRequest } from '@proton/signing-request';
import { Link, TransactArgs, TransactOptions, TransactResult } from './link';
import { LinkTransport } from './link-transport';
/**
 * Type describing a link session that can create a eosjs compatible
 * signature provider and transact for a specific auth.
 */
export declare abstract class LinkSession {
    /** @internal */
    constructor();
    /** The underlying link instance used by the session. */
    abstract link: Link;
    /** App identifier that owns the session. */
    abstract identifier: Name;
    /** Id of the chain where the session is valid. */
    abstract chainId: ChainId;
    /** The public key the session can sign for. */
    abstract publicKey: PublicKey;
    /** The EOSIO auth (a.k.a. permission level) the session can sign for. */
    abstract auth: PermissionLevel;
    /** Session type, e.g. 'channel'.  */
    abstract type: string;
    /** Arbitrary metadata that will be serialized with the session. */
    abstract metadata: {
        [key: string]: any;
    };
    /** Creates a eosjs compatible signature provider that can sign for the session public key. */
    abstract makeSignatureProvider(): any;
    /**
     * Transact using this session. See [[Link.transact]].
     */
    abstract transact(args: TransactArgs, options?: TransactOptions): Promise<TransactResult>;
    /** Returns a JSON-encodable object that can be used recreate the session. */
    abstract serialize(): SerializedLinkSession;
    /**
     * Convenience, remove this session from associated [[Link]] storage if set.
     * Equivalent to:
     * ```ts
     * session.link.removeSession(session.identifier, session.auth, session.chainId)
     * ```
     */
    remove(): Promise<void>;
    /** API client for the chain this session is valid on. */
    get client(): import("@proton/js").JsonRpc;
    /** Restore a previously serialized session. */
    static restore(link: Link, data: SerializedLinkSession): LinkSession;
}
/** @internal */
export interface SerializedLinkSession {
    type: string;
    metadata: {
        [key: string]: any;
    };
    data: any;
}
/** @internal */
interface ChannelInfo {
    /** Public key requests are encrypted to. */
    key: PublicKeyType;
    /** The wallet given channel name, usually the device name. */
    name: string;
    /** The channel push url. */
    url: string;
}
/** @internal */
export interface LinkChannelSessionData {
    /** App identifier that owns the session. */
    identifier: NameType;
    /** Authenticated user permission. */
    auth: PermissionLevelType;
    /** Public key of authenticated user */
    publicKey: PublicKeyType;
    /** The wallet channel url. */
    channel: ChannelInfo;
    /** The private request key. */
    requestKey: PrivateKeyType;
    /** The session chain id. */
    chainId: ChainIdType;
}
/**
 * Link session that pushes requests over a channel.
 * @internal
 */
export declare class LinkChannelSession extends LinkSession implements LinkTransport {
    readonly link: Link;
    readonly chainId: ChainId;
    readonly auth: PermissionLevel;
    readonly identifier: Name;
    readonly type = "channel";
    metadata: any;
    readonly publicKey: PublicKey;
    serialize: () => SerializedLinkSession;
    private timeout;
    private encrypt;
    private channelKey;
    private channelUrl;
    private channelName;
    constructor(link: Link, data: LinkChannelSessionData, metadata: any);
    onSuccess(request: any, result: any): void;
    onFailure(request: any, error: any): void;
    onRequest(request: SigningRequest, cancel: any): void;
    addLinkInfo(request: SigningRequest): void;
    prepare(request: any): Promise<any>;
    showLoading(): void;
    recoverError(error: Error, request: SigningRequest): boolean;
    makeSignatureProvider(): any;
    transact(args: TransactArgs, options?: TransactOptions): Promise<TransactResult>;
}
/** @internal */
export interface LinkFallbackSessionData {
    auth: PermissionLevelType;
    publicKey: PublicKeyType;
    identifier: NameType;
    chainId: ChainIdType;
}
/**
 * Link session that sends every request over the transport.
 * @internal
 */
export declare class LinkFallbackSession extends LinkSession implements LinkTransport {
    readonly link: Link;
    readonly chainId: ChainId;
    readonly auth: PermissionLevel;
    readonly type = "fallback";
    readonly identifier: Name;
    readonly metadata: {
        [key: string]: any;
    };
    readonly publicKey: PublicKey;
    serialize: () => SerializedLinkSession;
    constructor(link: Link, data: LinkFallbackSessionData, metadata: any);
    onSuccess(request: any, result: any): void;
    onFailure(request: any, error: any): void;
    onRequest(request: any, cancel: any): void;
    prepare(request: any): Promise<any>;
    showLoading(): void;
    makeSignatureProvider(): any;
    transact(args: TransactArgs, options?: TransactOptions): Promise<TransactResult>;
}
export {};
