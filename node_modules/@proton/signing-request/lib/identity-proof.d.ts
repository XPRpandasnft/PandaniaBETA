import { AuthorityType, PermissionLevel, PermissionLevelType, PublicKey, Signature, SignatureType, Struct, TimePointSec, TimePointType, Transaction } from '@greymass/eosio';
import { ChainId, ChainIdType } from './chain-id';
import { CallbackPayload, SigningRequestEncodingOptions } from './signing-request';
export declare type IdentityProofType = IdentityProof | string | {
    chainId: ChainIdType;
    expiration: TimePointType;
    signer: PermissionLevelType;
    signature: SignatureType;
};
export declare class IdentityProof extends Struct {
    chainId: ChainId;
    expiration: TimePointSec;
    signer: PermissionLevel;
    signature: Signature;
    static from(value: IdentityProofType): IdentityProof;
    /**
     * Create a new instance from an EOSIO authorization header string.
     * "EOSIO <base64payload>"
     */
    static fromString(string: string): IdentityProof;
    /** Create a new instance from a callback payload. */
    static fromPayload(payload: CallbackPayload, options?: SigningRequestEncodingOptions): IdentityProof;
    /**
     * Transaction this proof resolves to.
     * @internal
     */
    get transaction(): Transaction;
    /**
     * Recover the public key that signed this proof.
     */
    recover(): PublicKey;
    /**
     * Verify that given authority signed this proof.
     * @param auth The accounts signing authority.
     * @param currentTime Time to verify expiry against, if unset will use system time.
     */
    verify(auth: AuthorityType, currentTime?: TimePointType): boolean;
    /**
     * Encode the proof to an `EOSIO` auth header string.
     */
    toString(): string;
}
