import { ABIDef, ABISerializable, AnyAction, AnyTransaction, Bytes, Name, NameType, PermissionLevel, PermissionLevelType, Signature, Transaction } from '@greymass/eosio';
import { AbiProvider, CallbackPayload, ChainId, ChainIdType, IdentityProof, ResolvedSigningRequest, ResolvedTransaction, SigningRequest, SigningRequestCreateArguments, SigningRequestEncodingOptions } from '@proton/signing-request';
import { LinkOptions } from './link-options';
import { LinkSession } from './link-session';
import { LinkStorage } from './link-storage';
import { LinkTransport } from './link-transport';
import { LinkCallback } from './link-callback';
import { RpcInterfaces, JsonRpc } from '@proton/js';
/**
 * Payload accepted by the [[Link.transact]] method.
 * Note that one of `action`, `actions` or `transaction` must be set.
 */
export interface TransactArgs {
    /** Full transaction to sign. */
    transaction?: AnyTransaction;
    /** Action to sign. */
    action?: AnyAction;
    /** Actions to sign. */
    actions?: AnyAction[];
}
/**
 * Options for the [[Link.transact]] method.
 */
export interface TransactOptions {
    /**
     * Whether to broadcast the transaction or just return the signature.
     * Defaults to true.
     */
    broadcast?: boolean;
    /**
     * Chain to use when configured with multiple chains.
     */
    chain?: LinkChainType;
    /**
     * Whether the signer can make modifications to the request
     * (e.g. applying a cosigner action to pay for resources).
     *
     * Defaults to false if [[broadcast]] is true or unspecified; otherwise true.
     */
    noModify?: boolean;
}
/**
 * The result of a [[Link.transact]] call.
 */
export interface TransactResult {
    /** The resolved signing request. */
    resolved: ResolvedSigningRequest;
    /** The chain that was used. */
    chain: LinkChain;
    /** The transaction signatures. */
    signatures: Signature[];
    /** The callback payload. */
    payload: CallbackPayload;
    /** The signer authority. */
    signer: PermissionLevel;
    /** The resulting transaction. */
    transaction: Transaction;
    /** Resolved version of transaction, with the action data decoded. */
    resolvedTransaction: ResolvedTransaction;
    /** Push transaction response from api node, only present if transaction was broadcast. */
    processed?: {
        [key: string]: any;
    };
}
/**
 * The result of a [[Link.identify]] call.
 */
export interface IdentifyResult extends TransactResult {
    /** The identified account, not present unless [[LinkOptions.verifyProofs]] is set to true. */
    account?: RpcInterfaces.GetAccountResult;
    /** The identity proof. */
    proof: IdentityProof;
}
/**
 * The result of a [[Link.login]] call.
 */
export interface LoginResult extends IdentifyResult {
    /** The session created by the login. */
    session: LinkSession;
}
/**
 * Link chain, can be a [[LinkChain]] instance, a chain id or a index in [[Link.chains]].
 * @internal
 */
export declare type LinkChainType = LinkChain | ChainIdType | number;
/**
 * Class representing a EOSIO chain.
 */
export declare class LinkChain implements AbiProvider {
    /** EOSIO ChainID for which requests are valid. */
    chainId: ChainId;
    /** API client instance used to communicate with the chain. */
    client: JsonRpc;
    private abiCache;
    private pendingAbis;
    /** @internal */
    constructor(chainId: ChainIdType, clientOrUrl: JsonRpc | string);
    /**
     * Fetch the ABI for given account, cached.
     * @internal
     */
    getAbi(account: Name): Promise<ABIDef>;
}
/**
 * Proton Link main class.
 *
 * @example
 *
 * ```ts
 * import ProtonLink from 'proton-link'
 * import ConsoleTransport from 'proton-console-transport'
 *
 * const link = new ProtonLink({
 *     transport: new ConsoleTransport(),
 *     chains: [
 *         {
 *             chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',
 *             nodeUrl: 'https://eos.greymass.com',
 *         },
 *     ],
 * })
 *
 * const result = await link.transact({actions: myActions})
 * ```
 */
export declare class Link {
    /** Package version. */
    static version: string;
    /** Chains this instance is configured with. */
    readonly chains: LinkChain[];
    /** Transport used to deliver requests to the users wallet. */
    readonly transport: LinkTransport;
    /** Storage adapter used to persist sessions. */
    readonly storage?: LinkStorage;
    /** Scheme of request */
    readonly scheme: SigningRequestEncodingOptions['scheme'];
    /** Scheme of request */
    readonly walletType?: string;
    private callbackService;
    private verifyProofs;
    private encodeChainIds;
    /** Create a new link instance. */
    constructor(options: LinkOptions);
    /**
     * The APIClient instance for communicating with the node.
     * @note This returns the first APIClient when link is configured with multiple chains.
     */
    get client(): JsonRpc;
    /**
     * Return a [[LinkChain]] object for given chainId or chain reference.
     * @throws If this link instance has no configured chain for given reference.
     * @internal
     */
    getChain(chain: LinkChainType): LinkChain;
    /**
     * Create a SigningRequest instance configured for this link.
     * @internal
     */
    createRequest(args: SigningRequestCreateArguments, chain?: LinkChain, transport?: LinkTransport): Promise<{
        request: SigningRequest;
        callback: LinkCallback;
    }>;
    /**
     * Send a SigningRequest instance using this link.
     * @internal
     */
    sendRequest(request: SigningRequest, callback: LinkCallback, chain?: LinkChain, transport?: LinkTransport, broadcast?: boolean): Promise<TransactResult>;
    /**
     * Sign and optionally broadcast a EOSIO transaction, action or actions.
     *
     * Example:
     *
     * ```ts
     * let result = await myLink.transact({transaction: myTx})
     * ```
     *
     * @param args The action, actions or transaction to use.
     * @param options Options for this transact call.
     * @param transport Transport override, for internal use.
     */
    transact(args: TransactArgs, options?: TransactOptions, transport?: LinkTransport): Promise<TransactResult>;
    /**
     * Send an identity request and verify the identity proof if [[LinkOptions.verifyProofs]] is true.
     * @param args.scope The scope of the identity request.
     * @param args.requestPermission Optional request permission if the request is for a specific account or permission.
     * @param args.info Metadata to add to the request.
     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.
     */
    identify(args: {
        requestPermission?: PermissionLevelType;
        info?: {
            [key: string]: ABISerializable | Bytes;
        };
    }): Promise<IdentifyResult>;
    /**
     * Login and create a persistent session.
     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).
     *                   Should be set to the contract account if applicable.
     */
    login(identifier: NameType): Promise<LoginResult>;
    /**
     * Restore previous session, use [[login]] to create a new session.
     * @param identifier The session identifier, must be same as what was used when creating the session with [[login]].
     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.
     * @param chainId If given function will only consider that specific chain when restoring session.
     * @returns A [[LinkSession]] instance or null if no session can be found.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.
     **/
    restoreSession(identifier: NameType, auth?: PermissionLevelType, chainId?: ChainIdType): Promise<LinkSession | null>;
    /**
     * List stored session auths for given identifier.
     * The most recently used session is at the top (index 0).
     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.
     **/
    listSessions(identifier: NameType): Promise<{
        auth: PermissionLevel;
        chainId: ChainId;
    }[]>;
    /**
     * Remove stored session for given identifier and auth.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    removeSession(identifier: NameType, auth: PermissionLevel, chainId: ChainId): Promise<void>;
    /**
     * Remove all stored sessions for given identifier.
     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.
     */
    clearSessions(identifier: string): Promise<void>;
    /**
     * Create an eosjs compatible signature provider using this link.
     * @param availableKeys Keys the created provider will claim to be able to sign for.
     * @param chain Chain to use when configured with multiple chains.
     * @param transport (internal) Transport override for this call.
     * @note We don't know what keys are available so those have to be provided,
     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].
     */
    makeSignatureProvider(availableKeys: string[], chain?: LinkChainType, transport?: LinkTransport): any;
    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */
    private touchSession;
    /**
     * Makes sure session is in storage list of sessions and moves it to top (most recently used).
     * @internal
     */
    storeSession(session: LinkSession): Promise<void>;
    /** Session storage key for identifier and suffix. */
    private sessionKey;
    /**
     * Return user agent of this link.
     * @internal
     */
    getUserAgent(): string;
}
